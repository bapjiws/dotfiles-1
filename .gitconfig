[user]
	name = Dimytr Voitenko
	email = dimytr.voitenko@gmail.com
[core]
  editor = nvim
  excludesfile = ~/.global_gitignore
[commit]
	template = /Users/void/comtemp
[filter "lfs"]
	smudge = git-lfs smudge -- %f
	process = git-lfs filter-process
	required = true
	clean = git-lfs clean -- %f
[apply]
	# Detect whitespace errors when applying a patch
	whitespace = fix

[alias]
  a = add
  aa = add .
	c = commit
	amend = commit --amend --reuse-message=HEAD
	undo = reset HEAD~1 --mixed
	; clone = clone --template=/Users/void/.git-templates
  # push 
  p = push
  pf = push --force-with-lease
  # rebase
  rc = rebase --continue            # continue rebase
  rs = rebase --skip                # skip rebase

	# Show verbose output about tags, branches or remotes
	tags = tag -l
	branches = branch -a
	remotes = remote -v

  # emf: edit modified files
  # ecf: edit conflicted files
  # udf: untrack deleted files
  # dmb: delete merged branches
  emf = ! nvim -p `git status -s | cut -b 4- | grep -v '\\/$' | uniq`
  ecf = ! nvim -p `git ls-files --unmerged | cut -f2 | sort -u`
  udf = ! git rm `git ls-files --deleted | cut -f2 | sort -u`
  dmb = ! git branch --merged | grep -v \\* | grep -v master | xargs -n 1 git branch -d

	# View the current working tree status using the short format
  st = status --short --branch

  changelog = "!_() { t=$(git describe --abbrev=0 --tags); git log ${t}..HEAD --no-merges --pretty=format:'* %s'; }; _"

  # Interactive rebase with the given number of latest commits
	rebase-branch = "!r() { git rebase -i HEAD~$1; }; r"

  # respond to PR feedback
  pr ="!git commit --amend --reuse-message=HEAD --no-edit && git push --force-with-lease"

  # interactive sync your current branch with master
  sync = "!git fetch origin && git rebase --interactive origin/master"

  # Pull in remote changes for the current repository and all its submodules
  up = "!git pull --rebase --prune $@ && git submodule update --init --recursive"

	# Switch to a branch, creating it if necessary
	go = "!f() { git checkout -b \"$1\" 2> /dev/null || git checkout \"$1\"; }; f"

  # Checkout a pull request from origin (of a github repository)
  f = !"pr() { git fetch origin pull/$1/head:pr-$1; git checkout pr-$1; }; pr"

  unpushed = log --branches --not --remotes --no-walk --decorate --oneline

  conflicts = diff --name-only --diff-filter=U
  wtf = "! git log --pretty=tformat:\"%C(auto,yellow)%h%C(auto)%d%C(auto,reset) by %C(auto,blue)%cn%C(auto,reset), %C(auto,cyan)%ar%C(auto,reset)%n %s%n\" --stat"
  # nice logs
  lg = log --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset' --abbrev-commit --date=relative -n 10
  lgf = log --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset' --abbrev-commit --date=relative

	lines = ! git ls-files | xargs cat | wc -l

  fzfshow = "!f() { \
		git log --graph --color=always \
			--format=\"%C(auto)%h%d %s %C(black)%C(bold)%cr\" \"$@\" | \
		fzf --ansi --no-sort --reverse --tiebreak=index --bind=ctrl-s:toggle-sort \
			--bind \"ctrl-m:execute: \
				echo {} | grep -o '[a-f0-9]\\{7\\}' | head -1 | \
                xargs -I % sh -c 'git show --color=always % | less -R' \"; \
	}; f"

  # requires FZF
	autofixup = "!f() { COMMIT=$(git log --pretty=oneline | fzf | awk '{print $1}'); git commit --fixup $COMMIT; GIT_SEQUENCE_EDITOR=: git rebase --autostash --autosquash -i $COMMIT^; }; f"
  
  # commit all with an message (which need not be quoted)
  cm = "!f() { git commit -a -m \"$*\" ; }; f"

  save = "!git add -A && git commit -m 'SAVEPOINT'"
  wipe = "!git add -A && git commit -qm 'WIPE SAVEPOINT' && git reset HEAD~1 --hard"

  # fix your branch when it's missing upstream
  upstream = "!git branch --set-upstream-to=origin/$(git rev-parse --abbrev-ref HEAD) $(git rev-parse --abbrev-ref HEAD)"

	# List aliases
	aliases = config --get-regexp alias

[url "git@github.com:"]
  insteadOf = git://github.com/
  insteadOf = gh:
  insteadOf = github:
[push]
	default = current
[core]
	excludesfile = /Users/void/.gitignore_global
[difftool "sourcetree"]
	cmd = opendiff \"$LOCAL\" \"$REMOTE\"
	path = 
[mergetool "sourcetree"]
	cmd = /Applications/Sourcetree.app/Contents/Resources/opendiff-w.sh \"$LOCAL\" \"$REMOTE\" -ancestor \"$BASE\" -merge \"$MERGED\"
	trustExitCode = true
